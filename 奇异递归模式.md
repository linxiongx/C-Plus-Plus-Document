# 奇异递归模式



**奇异递归模式**（Curiously Recurring Template Pattern，简称 **CRTP**）是 C++ 中一种常见的模板编程惯用法。

它的核心定义非常简单，一句话就能概括：**一个类 `Derived` 继承自一个模板类 `Base`，并且把 `Derived` 自己作为模板参数传给 `Base`。**

### 1. 代码结构

CRTP 的基本骨架如下：

C++

```c++
// 1. 定义一个模板基类
template <typename T>
class Base {
    // ...
};

// 2. 派生类继承基类，并将自己(Derived)作为参数传回去
class Derived : public Base<Derived> {
    // ...
};
```

初看这种写法很奇怪（"奇异"），因为我们在定义 `Derived` 的时候，它还没有定义完整，却已经被用作 `Base` 的模板参数了。但在 C++ 中，这是合法的，因为只要在模板实例化时 `Derived` 是已知的即可。

------

### 2. 核心原理：静态多态 (Static Polymorphism)

CRTP 最主要的作用是实现**静态多态**。

通常我们用虚函数（`virtual`）来实现多态（运行时多态），但这会有性能开销（虚函数表查找、无法内联优化）。CRTP 允许我们在**编译期**模拟虚函数的行为。

它是如何工作的？

在基类中，我们可以通过 static_cast 将 this 指针转换为派生类类型的指针，从而调用派生类的方法。

#### 示例代码：

C++

```c++
#include <iostream>

// --- 基础结构 ---
template <typename T>
class Base {
public:
    void interface() {
        static_cast<T*>(this)->implementation();
    }
};

class DerivedA : public Base<DerivedA> {
public:
    void implementation() { std::cout << "我是 A 的实现" << std::endl; }
};

class DerivedB : public Base<DerivedB> {
public:
    void implementation() { std::cout << "我是 B 的实现" << std::endl; }
};

// --- 这才是重点：体现多态的统一接口 ---

// 这里的参数是 Base<T>&，它表示“任何继承自 Base 的类”
// 这是一个“编译期多态”的函数
template <typename T>
void execute_task(Base<T>& worker) {
    std::cout << "[开始任务] -> ";
    worker.interface(); // 这里的调用是多态的
    std::cout << "[结束任务]" << std::endl;
}

int main() {
    DerivedA a;
    DerivedB b;

    // 关键点来了：
    // execute_task 是同一个“函数名”（虽然底层生成了不同代码）
    // 但它接受了完全不同的类型 A 和 B，并且调用了各自正确的实现。
    
    execute_task(a); // 输出: [开始任务] -> 我是 A 的实现 ...
    execute_task(b); // 输出: [开始任务] -> 我是 B 的实现 ...

    return 0;
}
```

**与虚函数的区别：**

- **虚函数：** 程序运行时，通过虚表指针找到对应的函数地址。
- **CRTP：** 编译时，编译器就知道 `Base<DerivedA>::interface` 里调用的 `static_cast<DerivedA*>(this)->implementation()` 肯定是 `DerivedA` 的版本。编译器可以直接**内联 (Inline)** 这个调用，消除函数调用的开销。



### 3. 为什么说这是“多态”？

在上面的 `main` 中：

1. 我们看似调用了同一个接口 `execute_task(...)`。
2. 传入 `a` 时，它表现出 A 的行为。
3. 传入 `b` 时，它表现出 B 的行为。 这就是多态的定义：**同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。**

### 4. 它和“动态多态”（虚函数）的区别在哪里？

这是最容易混淆的地方。请看对比：

#### A. 动态多态 (Virtual) 的写法

C++

```
// 只需要写一次函数，编译生成一份二进制代码
void execute_task_dynamic(Base* worker) {
    worker->interface(); // 运行时查虚表，决定调哪个
}
```

- **特点**：`worker` 指针在运行时才知道指向的是 A 还是 B。

#### B. 静态多态 (CRTP) 的写法 (上面代码中的 `execute_task`)

C++

```
template <typename T>
void execute_task(Base<T>& worker) {
    worker.interface(); // 编译时直接绑定
}
```

- **特点**：编译器在编译阶段，看到 `execute_task(a)`，它会悄悄生成一份 `void execute_task(Base<DerivedA>&)` 的代码；看到 `execute_task(b)`，又生成一份 `void execute_task(Base<DerivedB>&)` 的代码。

- **本质**：表面上看是调用同一个函数，**实际上编译器为你生成了针对不同类型的专用版本**。

  

------

### 5. 主要应用场景

除了静态多态，CRTP 还有以下几个经典用途：

### 一、 核心好处

CRTP 的主要优势在于**性能**和**代码复用**，它在编译期完成了传统面向对象在运行期做的事情。

#### 1. 静态多态（零开销接口）

这是 CRTP 最著名的优点。

- **传统虚函数（动态多态）：** 需要维护虚函数表（vtable），调用时有指针跳转的开销（vptr lookup），且编译器很难对虚函数进行**内联（Inline）**优化。
- **CRTP（静态多态）：** 函数调用地址在编译期确定。没有虚表指针，没有运行时查找开销，且编译器可以完全内联代码。这对高性能计算（如图像处理、矩阵运算、高频交易）至关重要。

#### 2. 代码复用（倒置继承）

在普通继承中，基类通常不知道派生类的存在。但在 CRTP 中，**基类知道派生类的具体类型**。 这意味着基类可以编写通用的算法流程，而具体的实现细节可以下放给派生类，且不需要使用虚函数。

#### 3. 链式调用与类型保持

当基类函数返回 `*this` 时，CRTP 可以让基类函数返回派生类的类型（`Derived&`），而不是基类类型（`Base&`）。这在编写 Fluent Interface（链式调用 API）时非常有用。

------

### 二、 一般用在什么场景下？

#### 1. 高性能库的接口抽象

当你需要定义一个统一的接口，但无法容忍虚函数的开销时。

- **例子：** 著名的 C++ 线性代数库 **Eigen** 大量使用了 CRTP。矩阵运算非常频繁，如果是虚函数调用，性能损失巨大。
- **实现逻辑：** 基类负责通用的矩阵算法框架，派生类（如稀疏矩阵、稠密矩阵）负责具体的数据存储和访问。

#### 2. 混入类（Mixin）/ 功能注入

为现有的类添加特定的功能，例如：单例特性、对象计数、只能在堆上创建等。

- **标准库案例：** `std::enable_shared_from_this` 是一个经典的 CRTP 应用。

  C++

  ```
  class MyClass : public std::enable_shared_from_this<MyClass> {
      // 这样 MyClass 就获得了安全生成 shared_ptr 的能力
  };
  ```

#### 3. 操作符重载与自动生成

通过基类实现通用的操作符逻辑。例如，如果你实现了 `<`，你可以通过 CRTP 基类自动生成 `>`,`<=`, `>=`。

- **场景：** 只需要实现几个核心函数，基类利用这些核心函数推导出其他所有函数。

#### 4. 静态接口检查

强制派生类实现某些函数（类似于 Java 的 Interface，但在编译期检查）。如果派生类没有实现指定名称的函数，代码会在编译基类模板时报错。

当你在代码里调用基类的接口时，基类会把 `this` 指针强转为 `Derived*` 并调用 `Derived` 的函数。如果 `Derived` 里没有这个函数，编译器就会找不到符号，从而报错。

------

### 6. 优缺点总结

| **特性**     | **CRTP (静态多态)**                             | **虚函数 (动态多态)**                   |
| ------------ | ----------------------------------------------- | --------------------------------------- |
| **性能**     | **极高** (编译期解析，可内联)                   | 较低 (运行时查表，难内联)               |
| **代码体积** | 可能导致**代码膨胀** (每个模板实例生成一份代码) | 代码紧凑                                |
| **灵活性**   | 较低 (类型必须在编译期确定)                     | **高** (可以用基类指针存储不同子类对象) |
| **接口约束** | 隐式接口 (duck typing，只要有那个函数就行)      | 显式接口 (必须继承并 override)          |

**一句话建议：** 如果你的代码**极度追求性能**（如底层驱动、数学库、游戏引擎核心），或者需要**在编译期为类注入功能**（如 `enable_shared_from_this`），请使用 **CRTP**；如果是编写通用的业务逻辑，需要运行时灵活切换对象，传统虚函数依然是首选。